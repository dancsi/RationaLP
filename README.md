# RationaLP
## Rational dense linear program solver

To run the solver, execute
```
RationaLP input.txt [--pivot {bland, random, maxcoef or maxincrease}] [--verbose]
```
Note that in order to build the solver, you need Boost and GMP/MPIR installed somewhere where CMake can find them. On Debian-based systems, one would install `libboost-dev libboost-program-options-dev libgmp-dev`.

The input format is as follows:
```
n
m
c1 c2 ... cn
b1 b2 ... bm
a11 a12 ... a1n
a21 a22 ... a2n
...
am1 am2 ... amn
```
The problem that is solved is 
```
    max  c^T x
    s.t. A x <= b
           x >= 0
```

There are no restrictions on the range or number of (rational) variables, however, take note that each pivot step takes O(number of variables * number of constraints) time.

The following pivot rules are implemented

- `bland`: [Bland's rule](https://en.wikipedia.org/wiki/Bland%27s_rule)
- `random`: Random pivoting. Among all nonbasic variables that can increase the score, a random one enters the basis. If there are multiple variables that can leave the basis, a random one is chosen.
- `maxincrease`: Among all nonbasic variables that can increase the score, the one that increases the objective function the most enters the basis. If there are multiple variables that can leave the basis, the first one is chosen.
- `maxcoef`: The classic maximum coefficient rule, where the entering variable is the one with the greates coefficient in the objective function (in the current tableau).

Some tests are provided in the `inputs/` directory, and more can be generated by the following scripts

- `generate_random.py n m`, that generates a random feasible, unbounded and infeasible instance with `n` variables and `m` constraints. Surprisingly, in case of feasible instances the `maxcoef` rule performs the greatest number of pivots. On the other hand, for unbounded instances, Bland's rule is the worst-performing one. The code is adapted from [Mathematics Stackexchange: Generating random linear programming problems](https://math.stackexchange.com/a/244164/76028).
- `generate_klee_minty.py n`, that generates the [Klee-Minty](https://en.wikipedia.org/wiki/Klee%E2%80%93Minty_cube) hypercube of dimension `n`. These problems exhibit a pathological case of Bland's rule, which performs exponentially many pivots.
- `generate_vertex_cover.py n m`, that generates a random graph with `n` vertices and `m` edges, and outputs the LP relaxation of the corresponding vertex cover problem. This is choosen as an example of a real-world problem, where we obtain an approximate solution by taking the fractional relaxation of an integer linear program. Again, the `maxcoef` rule is the worst in this case, performing up to 80% worse than the others.

Across all generated inputs, the best-performing pivot rule (both by the total time spent, and the number of pivots) is `maxincrease`, and it is followed by `random`.  The overall last place goes to Bland's rule, as it spent both the greatest amount of time, and performed the greatest number of pivots. If we don't consider the Klee-Minty cubes, Bland's rule performs noticeably better than `maxcoef`.

Based on theses tests (random and vertex cover of sizes 50x50, 50x100, 100x50), it can also be concluded that the solver is much more sensitive to an increase in the number of constraints, especially in the case of unbounded inputs.

In order to verify that the solver works correctly, its output can be compared against the output of [Gurobi](http://www.gurobi.com/), using `test.py`. In order for the tests to work, one must have a valid Gurobi licence, and the Gurobi Python API installed. The easiest way to to so is to [install the `gurobi` package in Anaconda](http://www.gurobi.com/documentation/current/quickstart_windows/installing_the_anaconda_py.html#section:Anaconda). In addition to testing the correctness of the solver output, `test.py` also outputs a csv file (`test_output.csv`), which contains the performance measurements for all tests.
